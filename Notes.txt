Javascript has two ways to import files, one is Common js and other is Module Js.
import "" from "" is  Module Js syntax. It imports code Asynchronously.
Require() is Common Js syntax It imports code synchronously.
To use import we add  type : "Module" in package.json files

Axios: A Promise-based HTTP Client for Node.js and the Browser
Axios is a popular JavaScript library used for making HTTP requests from both the browser and Node.js. It simplifies the process of making HTTP requests and handling responses, providing an easy-to-use API.

Cross-Origin Resource Sharing (CORS) is a mechanism that allows web servers to control how resources are shared across different origins. It is implemented via HTTP headers and is crucial for web security, ensuring that only authorized domains can access resources while protecting users from malicious actions.

In simple language, CORS does not allow someone that is not from the same home. 

One of the solution is to install a CORS package, we can white list the urls using it. but we need to take care of these urls and ports while deploying applications.

To reduce the repeated writing of url, Proxy is used. 

Proxy for Handling CORS Errors
When your frontend application is making requests to a backend server on a different origin, the browser's same-origin policy may block these requests if the server does not permit them via CORS headers. A proxy server can help to bypass this issue by acting as an intermediary between your frontend and backend servers.

How It Works
Frontend Application: Makes a request to the proxy server (which is on the same origin as the frontend).
Proxy Server: Forwards the request to the actual backend server.
Backend Server: Sends the response back to the proxy server.
Proxy Server: Sends the response back to the frontend application.
Since the request from the frontend to the proxy is same-origin, CORS issues are avoided.

Database- 
 1. When connecting to databases, handling potential data-not-found scenarios is essential. Employ try/catch blocks or promises to manage errors or we can also use promises.
 2. Database operations involve latency, and traditional synchronous code can lead to blocking, where the program waits for the database query to complete before moving on. So, we should async/await which allows for non-blocking execution, enabling the program to continue with other tasks while waiting for the database response. 
 - Used two approach to connect the database - 1. In Index File, 2. In Seprate DB file


NOTE : Arrow function should not be used as a callback function in middlewares because it does not have the context of 'this' i.e. ongoing function.

Mongoose Aggregate paginate is a plugin that can be used to write mongoose complex queries.

bcrypt or bcryptjs library -  It is used to hash passwords
JWT - JSON Web Token - For hashing passwords, It creates tokens after hashing,
Tokens consist of three parts - Header (Algorithms and Token Type), Payload (Data), Signature used for encryting

JWT is a bearer token. Whoever has this token can access the data, it is like a key.

Files are uploaded using multer and stored using Cloudinary after the upload.

url = Uniform resourse locater
uri = Uniform resourse Identifier
urn = Uniform resourse Name

HTTP Headers - 
Metadata - data about some data - key value sent along with request and response
Used for caching, authentication, manage state(User logged in or not)

Request Headers  -  from Client
Response Headers  - from Server
Representation Headers  - encoding / compression
Payload Headers - data


Here is an extended explanation of each HTTP method:
1. GET:
Purpose: Retrieves data from the server.
Typical Use: Used when requesting data such as a webpage, image, or document. GET requests should be idempotent, meaning multiple identical requests will have the same effect as a single request.
Example: Fetching a list of users from a server (GET /users).
Characteristics: Does not modify server state, only retrieves data.

2. HEAD:
Purpose: Similar to GET, but without the response body.
Typical Use: Used to check what a GET request would return, without transferring the data. Often used for checking things like file metadata, caching information, or verifying that a resource exists.
Example: Checking if a file exists without downloading it (HEAD /file.txt).
Characteristics: Faster than GET as it only retrieves headers.

3. OPTIONS:
Purpose: Asks the server which HTTP methods are allowed or supported for a particular resource.
Typical Use: Used in CORS (Cross-Origin Resource Sharing) requests to check if the client has permission to interact with a resource.
Example: Checking the supported methods for a particular endpoint (OPTIONS /users might return GET, POST, OPTIONS).
Characteristics: Doesn't modify any resources, purely informational.

4. TRACE:
Purpose: Performs a message loopback test, where the request is echoed back to the client.
Typical Use: Used for diagnostic purposes to see how requests are being modified along the path to the server.
Example: Checking how intermediate servers might modify your HTTP request.
Characteristics: Rarely used in production and can expose sensitive information, so it's often disabled on servers for security reasons.

5. DELETE:
Purpose: Removes a resource from the server.
Typical Use: Used when you need to delete data, such as deleting a user account or a file.
Example: Deleting a user with DELETE /users/123.
Characteristics: Modifies server state by removing data. Idempotent, meaning if you DELETE the same resource multiple times, the result is the same (resource remains deleted).

6. PUT:
Purpose: Replaces an existing resource or creates a resource if it doesn't exist.
Typical Use: Used when you need to update a resource entirely, such as replacing a document or updating user information.
Example: Replacing a userâ€™s profile with PUT /users/123.
Characteristics: Idempotent. If the same PUT request is repeated, the result should be the same.

7. POST:
Purpose: Sends data to the server to create or modify a resource.
Typical Use: Used for creating new resources, such as submitting a form, adding a new user, or uploading a file.
Example: Creating a new user with POST /users.
Characteristics: Not idempotent. Multiple POST requests can result in multiple new resources being created (e.g., multiple users).

8. PATCH:
Purpose: Modifies part of an existing resource.
Typical Use: Used when you want to partially update an existing resource rather than replacing it entirely.
Example: Updating a user's email with PATCH /users/123 where only the email field is modified.
Characteristics: Unlike PUT, PATCH is not idempotent, meaning multiple PATCH requests may have different effects depending on the nature of the update.

HTTP Status Code
1xx: Informational
2xx: Success
3xx: Redirection
4xx: Client error
5xx: Server error

Codes:
100: Continue
102: Processing
200: OK
201: Created
202: Accepted
307: Temporary Redirect
308: Permanent Redirect

Client Errors:
400: Bad Request
401: Unauthorized
402: Payment Required
404: Not Found

Server Errors:
500: Internal Server Error
504: Gateway Timeout

Complete guide for router and controller:
1. Main App (app.js): The Express app is set up with app.use("/api/v1/users", userRouter) to handle routes related to users.
2. Routes (user.routes.js): When a POST request is made to /api/v1/users/register, it triggers the registerUser function in the controller.
3. Controller (users.controller.js): The registerUser function (wrapped in asyncHandler) sends a response with a status of 200 and a JSON message { message: 'ok' }. If there is an error, it will be caught by the asyncHandler.